{"version":3,"sources":["Component/gif.ts","Component/canvas.ts","Component/Url.tsx","Component/Loader.tsx","Component/storage.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["getBase64","file","a","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","getImage","url","image","Image","src","getDataUrl","xhr","XMLHttpRequest","onloadend","Error","response","open","responseType","send","getSuperGif","superGif","SuperGif","gif","auto_play","load","getGif","urlData","document","createElement","appendChild","get_frames","addImageToCanvas","context","imageData","croppedWidth","width","croppedHeight","top","height","putImageData","drawImage","canvas","getContext","getTrimedFrames","frameCount","Math","floor","delay","Array","map","_value","index","getFrame","length","totalFrames","frameNumber","frameStep","getOffsetY","generateSprite","images","key","toDataURL","Container","styled","div","Input","input","Button","span","Url","onChange","useState","setUrl","type","currentTarget","value","onClick","Canvas","Loading","Title","DropZone","Screen","OperationSelector","Operation","Player","canvasRef","useRef","useEffect","current","scale","data","scaleImage","timer","cpt","frames","setInterval","animateTrimed","clearInterval","ref","Loader","onSpriteUpdate","setGif","isLoading","setLoading","urlOpen","setUrlOpen","getImageData","getImages","then","files","gifData","newGif","window","requestFileSystem","webkitRequestFileSystem","removeFile","fs","filename","reject","root","getFile","create","fileEntry","remove","error","console","saveJSONFile","createWriter","fileWriter","onwriteend","onerror","write","Blob","JSON","stringify","getJSONFile","addEventListener","sprites","parse","readAsText","requestStorage","TEMPORARY","Download","Grid","Item","App","setSprites","setSprite","useCallback","sprite","clonedSprites","storedSprites","some","areSpriteEmpty","useSpriteState","updatedSprite","zip","JSZip","folder","forEach","replace","base64","generateAsync","content","saveAs","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","log","onUpdate","onSuccess","catch","ReactDOM","render","StrictMode","getElementById","URL","process","href","origin","fetch","headers","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"gSAIMA,EAAS,uCAAG,WAAOC,GAAP,SAAAC,EAAA,+EACT,IAAIC,SAAQ,SAACC,GAClB,IAAIC,EAAS,IAAIC,WAEjBD,EAAOE,OAAS,SAAUC,GACxBJ,EAAQI,EAAMC,OAAOC,SAGvBL,EAAOM,cAAcV,OARP,2CAAH,sDAWTW,EAAQ,uCAAG,WAAOC,GAAP,SAAAX,EAAA,+EACR,IAAIC,SAAQ,SAACC,GAClB,IAAIU,EAAQ,IAAIC,MAEhBD,EAAMP,OAAS,SAAUC,GACvBJ,EAAQU,IAGVA,EAAME,IAAMH,MARC,2CAAH,sDAYRI,EAAU,uCAAG,WAAOJ,GAAP,SAAAX,EAAA,+EACV,IAAIC,SAAQ,SAACC,GAClB,IAAIc,EAAM,IAAIC,eACdD,EAAIX,OAAS,WACX,IAAIF,EAAS,IAAIC,WACjBD,EAAOe,UAAY,WACjB,GAAI,OAASf,EAAOK,OAClB,MAAMW,MAAM,iBAAD,OAAkBR,EAAlB,MAGbT,EAAQC,EAAOK,SAEjBL,EAAOM,cAAcO,EAAII,WAE3BJ,EAAIK,KAAK,MAAOV,GAChBK,EAAIM,aAAe,OACnBN,EAAIO,WAhBW,2CAAH,sDAoBVC,EAAW,uCAAG,WAAOZ,GAAP,SAAAZ,EAAA,+EACX,IAAIC,SAAQ,SAACC,GAClB,IAAIuB,EAAW,IAAIC,IAAS,CAACC,IAAKf,EAAOgB,WAAW,IACpDH,EAASI,MAAK,WACZ3B,EAAQuB,UAJM,2CAAH,sDASXK,EAAM,uCAAG,WAAOC,GAAP,eAAA/B,EAAA,sEACOU,EAASqB,GADhB,cACPnB,EADO,OAEEoB,SAASC,cAAc,OAC/BC,YAAYtB,GAHN,SAKCY,EAAYZ,GALb,uCAKqBuB,cALrB,2CAAH,sDClDNC,EAAmB,SAACC,EAAmCC,GAC3D,IAAMC,EAAeD,EAAUE,MACzBC,EAAiBH,EAAUE,MANf,KACC,IAObE,GAAOJ,EAAUK,OAASF,GAAiB,EAEjDJ,EAAQO,aAAaN,EAAW,GAAII,EAHvB,EAGkCA,EAAKH,EAAcE,IAG9DI,EAAY,SAACC,EAA2BR,GAC5C,IAAMD,EAAUS,EAAOC,WAAW,MAC9B,OAASV,IAEbD,EAAiBC,EAASC,GAC1BD,EAAQQ,UAAUC,EAAQ,EAAG,EAlBX,KACC,OAoBfE,EAAkB,SAACrB,GACvB,IAAMsB,EAAaC,KAAKC,MApBD,KAoB0C,GAAfxB,EAAI,GAAGyB,QAEzD,OAAO,YAAI,IAAIC,MAAM,KAAKC,KAAI,SAACC,EAAaC,GAAd,OAC5BC,EAASR,GAActB,EAAI+B,OAAS/B,EAAI+B,OAAST,EAAYO,OAsC3DC,EAAW,SAACE,EAAqBC,GACrC,IAAMC,EAAYF,EAAc,GAEhC,OAAOT,KAAKC,MAAMS,EAAcC,IAsB5BC,EAAa,SAACN,GAAD,OAA2B,GAAK,IAAsBN,KAAKC,MAAMK,EAAQ,IAEtFO,EAAc,uCAAG,WAAOC,GAAP,mBAAAhE,EAAA,0DACf8C,EAASd,SAASC,cAAc,WAC/BO,MAAQ,KACfM,EAAOH,OAAS,KAEZ,QADEN,EAAUS,EAAOC,WAAW,OAJb,sBAKO5B,MAAM,wBALb,OAOrB,IAAS8C,KAAOD,EACd3B,EAAQO,aAAaoB,EAAOC,GAXc,EAWGA,EAX+B,EAA9B,KAWYH,EAAWG,IARlD,OAWrB5B,EAAQQ,UAAUC,EAAQ,EAAG,GAXR,kBAadA,EAAOoB,UAAU,cAbH,2CAAH,sD,qvBCzFpB,IAAMC,EAAYC,IAAOC,IAAV,KAaTC,EAAQF,IAAOG,MAAV,KAOLC,EAASJ,IAAOK,KAAV,KAiBNC,EAAM,SAAC,GAAqD,IAApDC,EAAmD,EAAnDA,SAAmD,EACzCC,mBAAS,IADgC,mBACxDjE,EADwD,KACnDkE,EADmD,KAG/D,OACE,kBAACV,EAAD,KACE,kBAACG,EAAD,CACEQ,KAAK,OACLH,SAAQ,uCAAE,WAAOrE,GAAP,SAAAN,EAAA,sDACR6E,EAAOvE,EAAMyE,cAAcC,OADnB,2CAAF,sDAGRA,MAAOrE,IAET,kBAAC6D,EAAD,CACES,QAAS,WACPN,EAAShE,GACTkE,EAAO,MAHX,Q,+7DCtCN,IAAMK,EAASd,IAAOtB,OAAV,KAQNqC,EAAUf,IAAOC,IAAV,KAcPe,EAAQhB,IAAOC,IAAV,KASLgB,EAAWjB,IAAOG,MAAV,KASRe,EAASlB,IAAOC,IAAV,KAQNkB,EAAoBnB,IAAOC,IAAV,KAajBmB,EAAYpB,IAAOC,IAAV,KA2BTF,EAAYC,IAAOC,IAAV,IAOTkB,GAMAE,EAAS,SAAC,GAAuB,IAAtB9D,EAAqB,EAArBA,IACT+D,EAAYC,iBAAO,MAazB,OAXAC,qBAAU,WACR,GAAI,OAASF,GAAa,OAASA,EAAUG,QAAS,EFhEvC,SAAC/C,EAA2BnB,GAC7C,IAAMmE,EAtDY,KAsDUnE,EAAI,GAAGoE,KAAKvD,MAEvCM,EAAOC,WAAW,MAAc+C,MAAMA,EAAOA,GE8D1CE,CAAWN,EAAUG,QAAgBlE,GACrC,IAAMsE,EFvFU,SAACnD,EAA2BnB,GAChD,IAAIuE,EAAM,EACJC,EAASnD,EAAgBrB,GAE/B,OAAOyE,aAAY,WACjB,IAAM9D,EAAYX,EAAIwE,EAAOD,EAAM,KAAKH,KACxClD,EAAUC,EAAQR,GAClB4D,MArCqB,IAsCD,IE+EJG,CAAcX,EAAUG,QAAgBlE,GAEtD,OAAO,WACL2E,cAAcL,OAGjB,CAACtE,IAEG,kBAACuD,EAAD,CAAQqB,IAAKb,EAAWlD,MF/Hb,KE+HiCG,OF9HhC,OEiIf6D,EAAS,SAAC,GAAwF,IAAvFC,EAAsF,EAAtFA,eAAgBjD,EAAsE,EAAtEA,MAAsE,EAC/EoB,mBAAc,IADiE,mBAC9FjD,EAD8F,KACzF+E,EADyF,OAErE9B,oBAAkB,GAFmD,mBAE9F+B,EAF8F,KAEnFC,EAFmF,OAGvEhC,oBAAkB,GAHqD,mBAG9FiC,EAH8F,KAGrFC,EAHqF,KAWrG,OANAlB,qBAAU,WACJ,IAAMjE,EAAI+B,QAEdK,EFrEc,SAACpC,EAAUwE,GAC3B,OAAOA,EAAO7C,KAAI,SAACW,GACjB,IAAMnB,EAASd,SAASC,cAAc,UACtCa,EAAON,MAxES,KAyEhBM,EAAOH,OAxEU,IAyEjB,IAAML,EAAYX,EAAIsC,GAAK8B,KACrBD,EA3EU,KA2EYxD,EAAUE,MAEhCH,EAAUS,EAAOC,WAAW,MAClC,GAAI,OAASV,EAAS,MAAMlB,MAAM,sBAKlC,OAJAiB,EAAiBC,EAASC,GAC1BD,EAAQyD,MAAMA,EAAOA,GACrBzD,EAAQQ,UAAUC,EAAQ,EAAG,GAEtBT,EAAQ0E,aAAa,EAAG,EAnFf,KACC,QEyIFC,CAAUrF,EAAKqB,EAAgBrB,KAAOsF,KAAKR,KACzD,CAAC9E,IAGF,kBAAC,EAAD,KACE,kBAAC2D,EAAD,KACE,kBAACF,EAAD,KAAQ5B,IAEM,IAAf7B,EAAI+B,QAAgB,kBAAC,EAAD,CAAQ/B,IAAKA,IAClC,kBAAC4D,EAAD,KACG,IAAM5D,EAAI+B,OACT,kBAAC8B,EAAD,CACEP,QAAS,WACPyB,EAAO,IACPD,EAAe,MAGjB,yCAGF,oCACE,kBAACjB,EAAD,CACEP,QAAS,WACP6B,GAAW,KAGb,sCAEF,kBAACtB,EAAD,KACE,sCACA,kBAACH,EAAD,CACEP,KAAK,OACLH,SAAQ,uCAAE,WAAOrE,GAAP,iBAAAN,EAAA,yDACJ,OAASM,EAAMC,OAAO2G,OAAS,cAAgB5G,EAAMC,OAAO2G,MAAM,GAAGpC,KADjE,wDAIR4B,EAAO,IACPE,GAAW,GALH,SAOc9G,EAAUQ,EAAMC,OAAO2G,MAAM,IAP3C,cAOFC,EAPE,gBAQarF,EAAOqF,GARpB,OAQFC,EARE,OASRV,EAAOU,GACPR,GAAW,GAVH,4CAAF,2DAiBjBC,GACC,kBAAC,EAAD,CACElC,SAAQ,uCAAE,WAAOhE,GAAP,iBAAAX,EAAA,6DACR0G,EAAO,IACPI,GAAW,GACXF,GAAW,GAHH,SAKc7F,EAAWJ,GALzB,cAKFwG,EALE,gBAMarF,EAAOqF,GANpB,OAMFC,EANE,OAORV,EAAOU,GACPR,GAAW,GARH,4CAAF,wDAYXD,GACC,kBAACxB,EAAD,KACE,kBAACC,EAAD,mB,0BC7MTiC,OAAeC,kBAAqBD,OAAeC,mBAAsBD,OAAeE,wBACzF,IAIMC,GAAU,uCAAG,WAAOC,EAASC,GAAhB,SAAA1H,EAAA,+EACV,IAAIC,SAAQ,SAACC,EAASyH,GAC3BF,EAAGG,KAAKC,QACNH,EACA,CAACI,QAAQ,IACT,SAACC,GACCA,EAAUC,QACR,WACE9H,OAEF,SAAC+H,GACCC,QAAQD,MAAMA,GACdN,EAAOM,SAIb,SAACA,GACCC,QAAQD,MAAMA,GACdN,EAAOM,UAlBI,2CAAH,wDAwBVE,GAAY,uCAAG,WAAOV,EAASC,EAAkB3B,GAAlC,SAAA/F,EAAA,sEACbwH,GAAWC,EAAIC,GADF,gCAGZ,IAAIzH,SAAQ,SAACC,EAASyH,GAC3BF,EAAGG,KAAKC,QACNH,EACA,CAACI,QAAQ,IACT,SAACC,GACCA,EAAUK,cACR,SAACC,GACCA,EAAWC,WAAa,SAAChI,GACvBJ,KAGFmI,EAAWE,QAAU,SAACN,GACpBC,QAAQD,MAAMA,GACdN,EAAOM,IAGTI,EAAWG,MAAM,IAAIC,KAAK,CAACC,KAAKC,UAAU5C,IAAQ,CAACjB,KAAM,yBAE3D,SAACmD,GACCC,QAAQD,MAAMA,GACdN,EAAOM,SAIb,SAACA,GACCC,QAAQD,MAAMA,GACdN,EAAOM,UA7BM,2CAAH,0DAmCZW,GAAW,uCAAG,WAAOnB,EAASC,GAAhB,SAAA1H,EAAA,+EACX,IAAIC,SAAQ,SAACC,EAASyH,GAC3BF,EAAGG,KAAKC,QACNH,EACA,CAACI,QAAQ,IACT,SAACC,GACCA,EAAUhI,KAAV,uCAAe,WAAOA,GAAP,eAAAC,EAAA,uDACPG,EAAS,IAAIC,YAEZyI,iBAAiB,WAAW,SAACvI,GAC9B,OAASA,EAAMyE,eAAe4C,EAAO,aACrC,OAAUrH,EAAMC,OAAsBC,QAAQmH,EAAO,aAEzD,IACE,IAAMmB,EAAUJ,KAAKK,MAAOzI,EAAMC,OAAsBC,QACxDN,EAAQ4I,GACR,MAAOb,GACPN,EAAOM,OAIX9H,EAAO6I,WAAWjJ,GAfL,2CAAf,0DAkBF,SAACkI,GACCC,QAAQD,MAAMA,GACdN,EAAOM,UA1BK,2CAAH,wDAgCXgB,GAAc,uCAAG,sBAAAjJ,EAAA,+EACd,IAAIC,SAAQ,SAACC,EAASyH,GAC1BN,OAAeC,kBAAmBD,OAAe6B,UAAW,UAAmBhJ,GAAS,SAAC+H,GACxFC,QAAQD,MAAMA,GACdN,EAAOM,UAJU,2CAAH,qD,2gBCzFpB,IAAMkB,GAAW/E,IAAOK,KAAV,MACRN,GAAYC,IAAOC,IAAV,MAMT+E,GAAOhF,IAAOC,IAAV,MAOJgF,GAAOjF,IAAOC,IAAV,MAsFKiF,OA9Cf,WAAgB,IAAD,EA/BQ,WAA4D,IAAD,EAClD1E,mBAAS,YAAI,IAAIvB,MAAM,KAAKC,KAAI,iBAAM,OADY,mBACzEwF,EADyE,KAChES,EADgE,KAG1EC,EAAYC,uBAChB,SAACjG,EAAekG,GACd,IAAMC,EAAa,YAAOb,GAC1Ba,EAAcnG,GAASkG,EAEvBH,EAAWI,KAEb,CAACb,IAkBH,OAfAlD,qBAAU,WACRqD,KAAiBhC,KAAjB,uCAAsB,WAAOQ,GAAP,eAAAzH,EAAA,sEACQ4I,GAAYnB,EAAI,eADxB,OACdmC,EADc,OAEpBL,EAAWK,GAFS,2CAAtB,yDAIC,IAEHhE,qBAAU,YAxBW,SAACkD,GACtB,OAAQA,EAAQe,MAAK,SAACH,GAAD,OAAY,IAAMA,EAAOhG,WAwBvCoG,CAAehB,IAClBG,KAAiBhC,KAAjB,uCAAsB,WAAOQ,GAAP,SAAAzH,EAAA,sEACdmI,GAAaV,EAAI,cAAeqB,GADlB,2CAAtB,yDAID,CAACA,IAEG,CAACA,EAASU,GAIaO,GADjB,mBACNjB,EADM,KACGS,EADH,KAGP9C,EAAiBgD,uBACrB,SAACjG,GAAD,OAAmB,SAACwG,GAClBT,EAAW/F,EAAOwG,MAEpB,CAACT,IAGH,OACE,kBAAC,GAAD,KACE,kBAACJ,GAAD,CACElE,QAAS,WACP,IAAMgF,EAAM,IAAIC,IACVC,EAASF,EAAIE,OAAO,QAC1BrB,EAAQsB,SAAQ,SAACV,EAAQlG,GACnB,KAAOkG,GAEXS,EAAOpK,KAAP,yCACoCyD,EAAQ,EAAI,GAAK,IAAM,IAD3D,OACgEA,EAAQ,EADxE,QAEEkG,EAAOW,QAAQ,yBAA0B,IACzC,CACEC,QAAQ,OAKdL,EAAIM,cAAc,CAACzF,KAAM,SAASmC,MAAK,SAAUuD,GAC/CC,kBAAOD,EAAS,iBAjBtB,YAuBA,kBAACpB,GAAD,KACGN,EAAQxF,KAAI,SAACC,EAAQC,GAAT,OACX,kBAAC6F,GAAD,CAAMpF,IAAKT,GACT,kBAAC,EAAD,CAAQiD,eAAgBA,EAAejD,GAAQA,MAAOA,EAAQ,WCvFpEkH,GAAcC,QACW,cAA7BtD,OAAOuD,SAASC,UAEe,UAA7BxD,OAAOuD,SAASC,UAEhBxD,OAAOuD,SAASC,SAASC,MACvB,2DA8CN,SAASC,GAAgBC,EAAeC,GACtCC,UAAUC,cACPC,SAASJ,GACT/D,MAAK,SAAAoE,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfR,UAAUC,cAAcQ,YAI1BzD,QAAQ0D,IACN,iHAKEX,GAAUA,EAAOY,UACnBZ,EAAOY,SAASR,KAMlBnD,QAAQ0D,IAAI,sCAGRX,GAAUA,EAAOa,WACnBb,EAAOa,UAAUT,WAO5BU,OAAM,SAAA9D,GACLC,QAAQD,MAAM,4CAA6CA,MClGjE+D,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFlK,SAASmK,eAAe,SDiBnB,SAAkBlB,GACvB,GAA6C,kBAAmBC,UAAW,CAMzE,GAJkB,IAAIkB,IACpBC,WACAhF,OAAOuD,SAAS0B,MAEJC,SAAWlF,OAAOuD,SAAS2B,OAIvC,OAGFlF,OAAOwB,iBAAiB,QAAQ,WAC9B,IAAMmC,EAAK,UAAMqB,WAAN,sBAEP3B,KAgEV,SAAiCM,EAAeC,GAE9CuB,MAAMxB,EAAO,CACXyB,QAAS,CAAE,iBAAkB,YAE5BxF,MAAK,SAAA7F,GAEJ,IAAMsL,EAActL,EAASqL,QAAQE,IAAI,gBAEnB,MAApBvL,EAASwL,QACO,MAAfF,IAA8D,IAAvCA,EAAYG,QAAQ,cAG5C3B,UAAUC,cAAc2B,MAAM7F,MAAK,SAAAoE,GACjCA,EAAa0B,aAAa9F,MAAK,WAC7BI,OAAOuD,SAASoC,eAKpBjC,GAAgBC,EAAOC,MAG1Bc,OAAM,WACL7D,QAAQ0D,IACN,oEAvFAqB,CAAwBjC,EAAOC,GAI/BC,UAAUC,cAAc2B,MAAM7F,MAAK,WACjCiB,QAAQ0D,IACN,iHAMJb,GAAgBC,EAAOC,OC1C/BE,K","file":"static/js/main.54f1df92.chunk.js","sourcesContent":["import SuperGif from 'libgif';\n\nexport type GIF = {data: ImageData; delay: number}[];\n\nconst getBase64 = async (file: File): Promise<string> => {\n  return new Promise((resolve) => {\n    var reader = new FileReader();\n\n    reader.onload = function (event: any) {\n      resolve(event.target.result);\n    };\n\n    reader.readAsDataURL(file);\n  });\n};\nconst getImage = async (url: string): Promise<HTMLImageElement> => {\n  return new Promise((resolve) => {\n    var image = new Image();\n\n    image.onload = function (event: any) {\n      resolve(image);\n    };\n\n    image.src = url;\n  });\n};\n\nconst getDataUrl = async (url: string): Promise<string> => {\n  return new Promise((resolve) => {\n    var xhr = new XMLHttpRequest();\n    xhr.onload = function () {\n      var reader = new FileReader();\n      reader.onloadend = function () {\n        if (null === reader.result) {\n          throw Error(`Cannot fetch \"${url}\"`);\n        }\n\n        resolve(reader.result as string);\n      };\n      reader.readAsDataURL(xhr.response);\n    };\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.send();\n  });\n};\n\nconst getSuperGif = async (image: HTMLImageElement): Promise<any> => {\n  return new Promise((resolve) => {\n    var superGif = new SuperGif({gif: image, auto_play: false});\n    superGif.load(() => {\n      resolve(superGif);\n    });\n  });\n};\n\nconst getGif = async (urlData: string): Promise<GIF> => {\n  const image = await getImage(urlData);\n  const parent = document.createElement('div');\n  parent.appendChild(image);\n\n  return (await getSuperGif(image)).get_frames();\n};\n\nexport {getGif, getImage, getBase64, getDataUrl};\n","import {GIF} from './gif';\n\nconst FRAME_WIDTH = 1014;\nconst FRAME_HEIGHT = 468;\nconst ANIMATION_LENGTH = 2000;\n\nconst addImageToCanvas = (context: CanvasRenderingContext2D, imageData: ImageData) => {\n  const croppedWidth = imageData.width;\n  const croppedHeight = (imageData.width / FRAME_WIDTH) * FRAME_HEIGHT;\n  const left = 0;\n  const top = (imageData.height - croppedHeight) / 2;\n\n  context.putImageData(imageData, 0, -top, left, top, croppedWidth, croppedHeight);\n};\n\nconst drawImage = (canvas: HTMLCanvasElement, imageData: ImageData) => {\n  const context = canvas.getContext('2d');\n  if (null === context) return;\n\n  addImageToCanvas(context, imageData);\n  context.drawImage(canvas, 0, 0, FRAME_WIDTH, FRAME_HEIGHT);\n};\n\nconst getTrimedFrames = (gif: GIF) => {\n  const frameCount = Math.floor(ANIMATION_LENGTH / (gif[0].delay * 10));\n\n  return [...new Array(30)].map((_value: any, index: number) =>\n    getFrame(frameCount >= gif.length ? gif.length : frameCount, index)\n  );\n};\nconst getSampledFrames = (gif: GIF) => {\n  return [...new Array(30)].map((_value: any, index: number) => getFrame(gif.length, index));\n};\n\nconst animateTrimed = (canvas: HTMLCanvasElement, gif: GIF): number => {\n  let cpt = 0;\n  const frames = getTrimedFrames(gif);\n\n  return setInterval(() => {\n    const imageData = gif[frames[cpt % 30]].data;\n    drawImage(canvas, imageData);\n    cpt++;\n  }, ANIMATION_LENGTH / 30);\n};\n\nconst animateSampled = (canvas: HTMLCanvasElement, gif: GIF): number => {\n  let cpt = 0;\n  const frames = getSampledFrames(gif);\n  return setInterval(() => {\n    const imageData = gif[frames[cpt % 30]].data;\n    drawImage(canvas, imageData);\n    cpt++;\n  }, ANIMATION_LENGTH / 30);\n};\n\nconst scaleImage = (canvas: HTMLCanvasElement, gif: GIF) => {\n  const scale = FRAME_WIDTH / gif[0].data.width;\n\n  (canvas.getContext('2d') as any).scale(scale, scale);\n};\n\nconst clearCanvas = (canvas: HTMLCanvasElement) => {\n  (canvas.getContext('2d') as any).clearRect(0, 0, FRAME_WIDTH, FRAME_HEIGHT);\n};\n\nconst getFrame = (totalFrames: number, frameNumber: number) => {\n  const frameStep = totalFrames / 30;\n\n  return Math.floor(frameNumber * frameStep);\n};\n\nconst getImages = (gif: GIF, frames: number[]): ImageData[] => {\n  return frames.map((key: number) => {\n    const canvas = document.createElement('canvas');\n    canvas.width = FRAME_WIDTH;\n    canvas.height = FRAME_HEIGHT;\n    const imageData = gif[key].data;\n    const scale = FRAME_WIDTH / imageData.width;\n\n    const context = canvas.getContext('2d');\n    if (null === context) throw Error('Cannot get context');\n    addImageToCanvas(context, imageData);\n    context.scale(scale, scale);\n    context.drawImage(canvas, 0, 0);\n\n    return context.getImageData(0, 0, FRAME_WIDTH, FRAME_HEIGHT);\n  });\n};\n\nconst getOffsetX = (index: number): number => 5 + (FRAME_WIDTH + 10) * (index % 4);\nconst getOffsetY = (index: number): number => 22 + (FRAME_HEIGHT + 44) * Math.floor(index / 4);\n\nconst generateSprite = async (images: ImageData[]): Promise<string> => {\n  const canvas = document.createElement('canvas');\n  canvas.width = 4096;\n  canvas.height = 4096;\n  const context = canvas.getContext('2d');\n  if (null === context) throw Error('Cannot create canvas');\n\n  for (let key in images) {\n    context.putImageData(images[key], getOffsetX(key as any), getOffsetY(key as any));\n  }\n\n  context.drawImage(canvas, 0, 0);\n\n  return canvas.toDataURL('image/png');\n};\n\nexport {\n  addImageToCanvas,\n  scaleImage,\n  animateTrimed,\n  animateSampled,\n  generateSprite,\n  getImages,\n  getTrimedFrames,\n  clearCanvas,\n  FRAME_WIDTH,\n  FRAME_HEIGHT,\n};\n","import React, {useState, ChangeEvent} from 'react';\nimport styled from 'styled-components';\n\nconst Container = styled.div`\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-color: rgb(233, 177, 61);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n`;\n\nconst Input = styled.input`\n  width: 80%;\n  border: none;\n  height: 30px;\n  padding-left: 5px;\n`;\n\nconst Button = styled.span`\n  width: 80%;\n  border: none;\n  height: 35px;\n  padding-left: 5px;\n  background-color: black;\n  color: white;\n  margin-top: 5px;\n  line-height: 35px;\n  text-align: center;\n  text-transform: uppercase;\n\n  &:hover {\n    cursor: pointer;\n  }\n`;\n\nconst Url = ({onChange}: {onChange: (value: string) => void}) => {\n  const [url, setUrl] = useState('');\n\n  return (\n    <Container>\n      <Input\n        type=\"text\"\n        onChange={async (event: ChangeEvent<HTMLInputElement>) => {\n          setUrl(event.currentTarget.value);\n        }}\n        value={url}\n      />\n      <Button\n        onClick={() => {\n          onChange(url);\n          setUrl('');\n        }}\n      >\n        Go\n      </Button>\n    </Container>\n  );\n};\n\nexport {Url};\n","import React, {ChangeEvent, useRef, useState, useEffect} from 'react';\nimport styled from 'styled-components';\nimport {getGif, getBase64, GIF, getImage, getDataUrl} from './gif';\nimport {\n  scaleImage,\n  animateTrimed,\n  generateSprite,\n  getImages,\n  getTrimedFrames,\n  FRAME_WIDTH,\n  FRAME_HEIGHT,\n} from './canvas';\nimport {Url} from './Url';\n\nconst Canvas = styled.canvas`\n  top: 0px;\n  left: 0px;\n  width: 338px;\n  height: 156px;\n  position: absolute;\n`;\n\nconst Loading = styled.div`\n  top: 0px;\n  left: 0px;\n  width: 338px;\n  height: 156px;\n  position: absolute;\n  background-color: rgb(208, 44, 51);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  height: 100%;\n`;\n\nconst Title = styled.div`\n  color: white;\n  font-size: 28px;\n  font-family: sans-serif;\n  font-weight: 100;\n  text-align: center;\n  width: 100%;\n`;\n\nconst DropZone = styled.input`\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  opacity: 0;\n`;\n\nconst Screen = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  height: 100%;\n`;\n\nconst OperationSelector = styled.div`\n  top: 0px;\n  left: 0px;\n  width: 338px;\n  height: 156px;\n  position: absolute;\n  display: flex;\n  align-items: center;\n  text-transform: uppercase;\n  font-size: 20px;\n  display: none;\n`;\n\nconst Operation = styled.div`\n  flex: 1;\n  color: white;\n  text-align: center;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n\n  &:hover {\n    cursor: pointer;\n  }\n\n  &:nth-child(n + 1) {\n    background-color: rgb(233, 177, 61);\n  }\n\n  &:nth-child(n + 2) {\n    background-color: rgb(39, 94, 132);\n  }\n\n  &:nth-child(n + 3) {\n    background-color: rgb(37, 90, 48);\n  }\n`;\n\nconst Container = styled.div`\n  width: 338px;\n  height: 156px;\n  background: black;\n  position: relative;\n\n  &:hover {\n    ${OperationSelector} {\n      display: flex;\n    }\n  }\n`;\n\nconst Player = ({gif}: {gif: GIF}) => {\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    if (null !== canvasRef && null !== canvasRef.current) {\n      scaleImage(canvasRef.current as any, gif);\n      const timer = animateTrimed(canvasRef.current as any, gif);\n\n      return () => {\n        clearInterval(timer);\n      };\n    }\n  }, [gif]);\n\n  return <Canvas ref={canvasRef} width={FRAME_WIDTH} height={FRAME_HEIGHT}></Canvas>;\n};\n\nconst Loader = ({onSpriteUpdate, index}: {onSpriteUpdate: (sprite: string) => void; index: number}) => {\n  const [gif, setGif] = useState<GIF>([]);\n  const [isLoading, setLoading] = useState<boolean>(false);\n  const [urlOpen, setUrlOpen] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (0 === gif.length) return;\n\n    generateSprite(getImages(gif, getTrimedFrames(gif))).then(onSpriteUpdate);\n  }, [gif]);\n\n  return (\n    <Container>\n      <Screen>\n        <Title>{index}</Title>\n      </Screen>\n      {gif.length !== 0 && <Player gif={gif} />}\n      <OperationSelector>\n        {0 !== gif.length ? (\n          <Operation\n            onClick={() => {\n              setGif([]);\n              onSpriteUpdate('');\n            }}\n          >\n            <span>Remove</span>\n          </Operation>\n        ) : (\n          <>\n            <Operation\n              onClick={() => {\n                setUrlOpen(true);\n              }}\n            >\n              <span>Url</span>\n            </Operation>\n            <Operation>\n              <span>File</span>\n              <DropZone\n                type=\"file\"\n                onChange={async (event: ChangeEvent<HTMLInputElement>) => {\n                  if (null === event.target.files || 'image/gif' !== event.target.files[0].type) {\n                    return;\n                  }\n                  setGif([]);\n                  setLoading(true);\n\n                  const gifData = await getBase64(event.target.files[0]);\n                  const newGif = await getGif(gifData);\n                  setGif(newGif);\n                  setLoading(false);\n                }}\n              />\n            </Operation>\n          </>\n        )}\n      </OperationSelector>\n      {urlOpen && (\n        <Url\n          onChange={async (url: string) => {\n            setGif([]);\n            setUrlOpen(false);\n            setLoading(true);\n\n            const gifData = await getDataUrl(url);\n            const newGif = await getGif(gifData);\n            setGif(newGif);\n            setLoading(false);\n          }}\n        />\n      )}\n      {isLoading && (\n        <Loading>\n          <Title>Loading</Title>\n        </Loading>\n      )}\n    </Container>\n  );\n};\n\nexport {Loader};\n","(window as any).requestFileSystem = (window as any).requestFileSystem || (window as any).webkitRequestFileSystem;\nconst onError = (error: any) => {\n  console.error(error);\n};\n\nconst removeFile = async (fs: any, filename: string) => {\n  return new Promise((resolve, reject) => {\n    fs.root.getFile(\n      filename,\n      {create: true},\n      (fileEntry: any) => {\n        fileEntry.remove(\n          function () {\n            resolve();\n          },\n          (error: any) => {\n            console.error(error);\n            reject(error);\n          }\n        );\n      },\n      (error: any) => {\n        console.error(error);\n        reject(error);\n      }\n    );\n  });\n};\n\nconst saveJSONFile = async (fs: any, filename: string, data: any) => {\n  await removeFile(fs, filename);\n\n  return new Promise((resolve, reject) => {\n    fs.root.getFile(\n      filename,\n      {create: true},\n      (fileEntry: any) => {\n        fileEntry.createWriter(\n          (fileWriter: any) => {\n            fileWriter.onwriteend = (event: any) => {\n              resolve();\n            };\n\n            fileWriter.onerror = (error: any) => {\n              console.error(error);\n              reject(error);\n            };\n\n            fileWriter.write(new Blob([JSON.stringify(data)], {type: 'application/json'}));\n          },\n          (error: any) => {\n            console.error(error);\n            reject(error);\n          }\n        );\n      },\n      (error: any) => {\n        console.error(error);\n        reject(error);\n      }\n    );\n  });\n};\n\nconst getJSONFile = async (fs: any, filename: string): Promise<any[]> => {\n  return new Promise((resolve, reject) => {\n    fs.root.getFile(\n      filename,\n      {create: true},\n      (fileEntry: any) => {\n        fileEntry.file(async (file: Blob) => {\n          const reader = new FileReader();\n\n          reader.addEventListener('loadend', (event) => {\n            if (null === event.currentTarget) reject('no target');\n            if (null === (event.target as FileReader).result) reject('no result');\n\n            try {\n              const sprites = JSON.parse((event.target as FileReader).result as string);\n              resolve(sprites);\n            } catch (error) {\n              reject(error);\n            }\n          });\n\n          reader.readAsText(file);\n        });\n      },\n      (error: any) => {\n        console.error(error);\n        reject(error);\n      }\n    );\n  });\n};\n\nconst requestStorage = async () => {\n  return new Promise((resolve, reject) => {\n    (window as any).requestFileSystem((window as any).TEMPORARY, 1024 * 1024 * 200, resolve, (error: any) => {\n      console.error(error);\n      reject(error);\n    });\n  });\n};\n\nexport {requestStorage, getJSONFile, saveJSONFile};\n","import React, {useState, useCallback, useEffect} from 'react';\nimport {Loader} from './Component/Loader';\nimport styled from 'styled-components';\nimport JSZip from 'jszip';\nimport {saveAs} from 'file-saver';\nimport {requestStorage, saveJSONFile, getJSONFile} from './Component/storage';\n\nconst Download = styled.span``;\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n\nconst Grid = styled.div`\n  display: grid;\n  grid-gap: 10px;\n  grid-template-columns: repeat(auto-fill, minmax(338px, 1fr));\n  width: 95vw;\n`;\n\nconst Item = styled.div`\n  display: flex;\n  justify-content: center;\n`;\n\nconst areSpriteEmpty = (sprites: string[]) => {\n  return !sprites.some((sprite) => 0 !== sprite.length);\n};\n\nconst useSpriteState = (): [string[], (index: number, sprite: string) => void] => {\n  const [sprites, setSprites] = useState([...new Array(16)].map(() => ''));\n\n  const setSprite = useCallback(\n    (index: number, sprite: string) => {\n      const clonedSprites = [...sprites];\n      clonedSprites[index] = sprite;\n\n      setSprites(clonedSprites);\n    },\n    [sprites]\n  );\n\n  useEffect(() => {\n    requestStorage().then(async (fs: any) => {\n      const storedSprites = await getJSONFile(fs, 'images.json');\n      setSprites(storedSprites);\n    });\n  }, []);\n\n  useEffect(() => {\n    if (!areSpriteEmpty(sprites)) {\n      requestStorage().then(async (fs: any) => {\n        await saveJSONFile(fs, 'images.json', sprites);\n      });\n    }\n  }, [sprites]);\n\n  return [sprites, setSprite];\n};\n\nfunction App() {\n  const [sprites, setSprites] = useSpriteState();\n\n  const onSpriteUpdate = useCallback(\n    (index: number) => (updatedSprite: string) => {\n      setSprites(index, updatedSprite);\n    },\n    [setSprites]\n  );\n\n  return (\n    <Container>\n      <Download\n        onClick={() => {\n          const zip = new JSZip();\n          const folder = zip.folder('GIFs');\n          sprites.forEach((sprite, index) => {\n            if ('' === sprite) return;\n\n            folder.file(\n              `GIF-Looper-Template-Spritesheet${index + 1 < 10 ? '0' : ''}${index + 1}.png`,\n              sprite.replace('data:image/png;base64,', ''),\n              {\n                base64: true,\n              }\n            );\n          });\n\n          zip.generateAsync({type: 'blob'}).then(function (content) {\n            saveAs(content, 'GIFs.zip');\n          });\n        }}\n      >\n        Download\n      </Download>\n      <Grid>\n        {sprites.map((_value, index: number) => (\n          <Item key={index}>\n            <Loader onSpriteUpdate={onSpriteUpdate(index)} index={index + 1} />\n          </Item>\n        ))}\n      </Grid>\n    </Container>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}