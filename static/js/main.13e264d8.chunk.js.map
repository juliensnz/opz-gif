{"version":3,"sources":["Component/gif.ts","Component/canvas.ts","Component/loader.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["getBase64","file","a","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","getImage","url","image","Image","src","getSuperGif","superGif","SuperGif","gif","auto_play","load","getGif","urlData","document","createElement","appendChild","get_frames","addImageToCanvas","context","imageData","croppedWidth","width","croppedHeight","top","height","putImageData","drawImage","canvas","getContext","getTrimedFrames","frameCount","Math","floor","delay","Array","map","_value","index","getFrame","length","totalFrames","frameNumber","frameStep","getOffsetY","generateSprite","images","Error","key","toDataURL","Canvas","styled","Container","div","DropZone","input","Loader","onSpriteUpdate","useState","gifData","setGifData","canvasRef","useRef","useEffect","current","console","log","then","scale","data","scaleImage","cpt","frames","setInterval","animateTrimed","getImageData","getImages","ref","type","onChange","files","Download","span","App","sprites","setSprites","setSprite","useCallback","sprite","clonedSprites","useSpriteState","updatedSprite","onClick","zip","JSZip","folder","forEach","replace","base64","generateAsync","content","saveAs","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","StrictMode","getElementById","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.13e264d8.chunk.js","sourcesContent":["import SuperGif from 'libgif';\n\nexport type GIF = {data: ImageData, delay: number}[]\n\nconst getBase64 = async (file: File): Promise<string> => {\n  return new Promise((resolve) => {\n    var reader = new FileReader();\n\n    reader.onload = function(event: any) {\n      resolve(event.target.result)\n    }\n\n    reader.readAsDataURL(file);\n  });\n}\nconst getImage = async (url: string): Promise<HTMLImageElement>=> {\n  return new Promise((resolve) => {\n    var image = new Image();\n\n    image.onload = function(event: any) {\n      resolve(image)\n    }\n\n    image.src = url;\n  });\n}\n\nconst getSuperGif = async (image: HTMLImageElement): Promise<any> => {\n  return new Promise((resolve) => {\n    var superGif = new SuperGif({ gif: image, auto_play: false } );\n    superGif.load(() => {\n      resolve(superGif);\n    });\n  });\n}\n\nconst getGif = async (urlData: string): Promise<GIF> => {\n  const image = await getImage(urlData);\n  const parent = document.createElement('div');\n  parent.appendChild(image);\n\n  return (await getSuperGif(image)).get_frames();\n}\n\nexport {getGif, getImage, getBase64};\n","import {GIF} from './gif';\n\nconst FRAME_WIDTH = 1014;\nconst FRAME_HEIGHT = 468;\nconst ANIMATION_LENGTH = 2000;\n\nconst addImageToCanvas = (context: CanvasRenderingContext2D, imageData: ImageData) => {\n  const croppedWidth = imageData.width;\n  const croppedHeight = (imageData.width / FRAME_WIDTH) * FRAME_HEIGHT;\n  const left = 0;\n  const top = (imageData.height - croppedHeight) / 2;\n\n  context.putImageData(imageData, 0, -top, left, top, croppedWidth, croppedHeight);\n}\n\nconst drawImage = (canvas: HTMLCanvasElement, imageData: ImageData) => {\n  const context = canvas.getContext('2d');\n  if (null === context) return;\n\n  addImageToCanvas(context, imageData);\n  context.drawImage(canvas, 0, 0);\n}\n\n\nconst getTrimedFrames = (gif: GIF) => {\n  const frameCount = Math.floor(ANIMATION_LENGTH / (gif[0].delay * 10));\n\n  return [...(new Array(30))].map((_value: any, index: number) => getFrame(frameCount >= gif.length ? gif.length : frameCount, index));\n}\nconst getSampledFrames = (gif: GIF) => {\n  return [...(new Array(30))].map((_value: any, index: number) => getFrame(gif.length, index));\n}\n\nconst animateTrimed = (canvas: HTMLCanvasElement, gif: GIF) => {\n  let cpt = 0;\n  const frames = getTrimedFrames(gif);\n\n  setInterval(() => {\n    const imageData = gif[frames[cpt % 30]].data;\n    drawImage(canvas, imageData);\n    cpt++;\n  }, ANIMATION_LENGTH / 30);\n}\n\nconst animateSampled = (canvas: HTMLCanvasElement, gif: GIF) => {\n  let cpt = 0;\n  const frames = getSampledFrames(gif);\n  setInterval(() => {\n    const imageData = gif[frames[cpt % 30]].data;\n    drawImage(canvas, imageData);\n    cpt++;\n  }, ANIMATION_LENGTH / 30);\n}\n\n\nconst scaleImage = (canvas: HTMLCanvasElement, gif: GIF) => {\n  const scale = FRAME_WIDTH / gif[0].data.width;\n\n  (canvas.getContext('2d') as any).scale(scale, scale);\n}\n\nconst getFrame = (totalFrames: number, frameNumber: number) => {\n  const frameStep = totalFrames / 30;\n\n  return Math.floor(frameNumber * frameStep);\n}\n\nconst getImages = (gif: GIF, frames: number[]): ImageData[] => {\n  return frames.map((key: number) => {\n    const canvas = document.createElement('canvas');\n    canvas.width = FRAME_WIDTH;\n    canvas.height = FRAME_HEIGHT;\n    const imageData = gif[key].data;\n    const scale = FRAME_WIDTH / imageData.width;\n\n    const context = canvas.getContext('2d');\n    if (null === context) throw Error('Cannot get context');\n    addImageToCanvas(context, imageData);\n    context.scale(scale, scale);\n    context.drawImage(canvas, 0, 0);\n\n    return context.getImageData(0, 0, FRAME_WIDTH, FRAME_HEIGHT);\n  })\n}\n\nconst getOffsetX = (index: number): number => 5 + ((FRAME_WIDTH + 10) * (index % 4));\nconst getOffsetY = (index: number): number => 22 + ((FRAME_HEIGHT + 44) * (Math.floor(index/4)));\n\nconst generateSprite = async (images: ImageData[]): Promise<string> => {\n  const canvas = document.createElement('canvas');\n  canvas.width = 4096;\n  canvas.height = 4096;\n  const context = canvas.getContext('2d');\n  if (null === context) throw Error('Cannot create canvas');\n\n  for (let key in images) {\n    context.putImageData(images[key], getOffsetX(key as any), getOffsetY(key as any));\n  }\n\n  context.drawImage(canvas, 0, 0);\n\n  return canvas.toDataURL('image/png');\n}\n\nexport {addImageToCanvas, scaleImage, animateTrimed, animateSampled, generateSprite, getImages, getTrimedFrames, FRAME_WIDTH, FRAME_HEIGHT}\n","import React, {ChangeEvent, useRef, useState, useEffect} from 'react';\nimport styled from 'styled-components';\nimport {getGif, getBase64} from './gif';\nimport {\n  scaleImage,\n  animateTrimed,\n  generateSprite,\n  getImages,\n  getTrimedFrames,\n  FRAME_WIDTH,\n  FRAME_HEIGHT,\n} from './canvas';\n\nconst Canvas = styled.canvas`\n  top: 0px;\n  left: 0px;\n  width: 338px;\n  height: 156px;\n  position: absolute;\n`;\n\nconst Container = styled.div`\n  width: 338px;\n  height: 156px;\n  background: black;\n  position: relative;\n  margin-right: 20px;\n`;\nconst DropZone = styled.input`\n  top: 0px;\n  left: 0px;\n  width: 338px;\n  height: 156px;\n  position: absolute;\n  opacity: 0;\n`;\n\nconst Loader = ({onSpriteUpdate}: {onSpriteUpdate: (sprite: string) => void}) => {\n  const [gifData, setGifData] = useState('');\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    if (null !== canvasRef && null !== canvasRef.current) {\n      console.log('restart');\n      getGif(gifData).then((gif) => {\n        scaleImage(canvasRef.current as any, gif);\n        animateTrimed(canvasRef.current as any, gif);\n        generateSprite(getImages(gif, getTrimedFrames(gif))).then(onSpriteUpdate);\n      });\n    }\n  }, [gifData]);\n\n  return (\n    <Container>\n      <Canvas ref={canvasRef} width={FRAME_WIDTH} height={FRAME_HEIGHT}></Canvas>\n      <DropZone\n        type=\"file\"\n        onChange={async (event: ChangeEvent<HTMLInputElement>) => {\n          if (null === event.target.files || 'image/gif' !== event.target.files[0].type) {\n            return;\n          }\n\n          setGifData(await getBase64(event.target.files[0]));\n        }}\n      />\n    </Container>\n  );\n};\n\nexport {Loader};\n","import React, {useState, useCallback} from 'react';\nimport {Loader} from './Component/loader';\nimport styled from 'styled-components';\nimport JSZip from 'jszip';\nimport {saveAs} from 'file-saver';\n\nconst Download = styled.span``;\n\nconst Container = styled.div`\n  display: grid;\n  grid-gap: 20px;\n  grid-template-columns: repeat(auto-fill, minmax(338px, 1fr));\n`;\n\nconst useSpriteState = (): [string[], (index: number, sprite: string) => void] => {\n  const [sprites, setSprites] = useState([...new Array(16)].map(() => ''));\n\n  const setSprite = useCallback(\n    (index: number, sprite: string) => {\n      const clonedSprites = [...sprites];\n      clonedSprites[index] = sprite;\n\n      setSprites(clonedSprites);\n    },\n    [sprites]\n  );\n\n  return [sprites, setSprite];\n};\n\nfunction App() {\n  const [sprites, setSprites] = useSpriteState();\n\n  const onSpriteUpdate = useCallback(\n    (index: number) => (updatedSprite: string) => {\n      setSprites(index, updatedSprite);\n    },\n    [setSprites]\n  );\n\n  return (\n    <>\n      <Download\n        onClick={() => {\n          const zip = new JSZip();\n          const folder = zip.folder('GIFs');\n          sprites.forEach((sprite, index) => {\n            if ('' === sprite) return;\n            console.log(sprite);\n            folder.file(\n              `GIF-Looper-Template-Spritesheet${index + 1 < 10 ? '0' : ''}${index + 1}.png`,\n              sprite.replace('data:image/png;base64,', ''),\n              {\n                base64: true,\n              }\n            );\n          });\n\n          zip.generateAsync({type: 'blob'}).then(function (content) {\n            saveAs(content, 'GIFs.zip');\n          });\n        }}\n      >\n        Download\n      </Download>\n      <Container>\n        {sprites.map((_value, index: number) => (\n          <Loader key={index} onSpriteUpdate={onSpriteUpdate(index)} />\n        ))}\n      </Container>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}